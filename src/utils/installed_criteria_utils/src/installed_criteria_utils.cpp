/**
 * @file installed_criteria_utils.hpp
 * @brief Contains utilities for managing Installed-Criteria data.
 *
 * @copyright Copyright (c) Microsoft Corp.
 * Licensed under the MIT License.
 */
#include "aduc/installed_criteria_utils.hpp"
#include "aduc/adu_core_exports.h"
#include "aduc/logging.h"
#include <chrono>
#include <fstream>
#include <parson.h>
#include <sstream>

/**
 * @brief Checks if the installed content matches the installed criteria.
 *
 * @param installedCriteria The installed criteria string. e.g. The firmware version or APT id.
 *  installedCriteria has already been checked to be non-empty before this call.
 *
 * @return ADUC_Result
 */
const ADUC_Result GetIsInstalled(const char* installedCriteriaFilePath, const std::string& installedCriteria)
{
    // For any error, we'll return 'Not Installed'.
    ADUC_Result result = ADUC_Result{ ADUC_Result_IsInstalled_NotInstalled };
    Log_Info("Evaluating installedCriteria %s", installedCriteria.c_str());

    JSON_Value* rootValue = json_parse_file(installedCriteriaFilePath);
    if (rootValue != nullptr)
    {
        JSON_Array* icArray = json_value_get_array(rootValue);
        bool foundInstalledCriteria = false;
        for (size_t i = 0; i < json_array_get_count(icArray); i++)
        {
            JSON_Object* icObject = json_array_get_object(icArray, i);
            if (icObject != nullptr)
            {
                const char* criteria = json_object_get_string(icObject, "installedCriteria");
                const std::string state = json_object_get_string(icObject, "state");

                Log_Debug("Found installedCriteria: %s, state:%s ", criteria, state.c_str());
                if ((criteria != nullptr) && (installedCriteria == criteria))
                {
                    foundInstalledCriteria = true;
                    result = ADUC_Result{ state == "installed" ? ADUC_Result_IsInstalled_Installed
                                                               : ADUC_Result_IsInstalled_NotInstalled };
                    if (result.ResultCode == ADUC_Result_IsInstalled_NotInstalled)
                    {
                        Log_Info(
                            "Installed criteria %s is found, but the state is %s, not Installed",
                            installedCriteria.c_str(),
                            state.c_str());
                    }
                    break;
                }
            }
        }
        if (!foundInstalledCriteria)
        {
            Log_Info("Installed criteria %s is not found in the list of packages.", installedCriteria.c_str());
        }

        json_value_free(rootValue);
    }

    return result;
}

/**
 * @brief Serialize specified JSON_Value and atomically save to specified file.
 * Note that this function will write serialized data to a temp file, then rename (or replace the existing file)
 * the temp file to specified 'filename'.
 *
 * The temp filename is generated by appending an epoch time to specified 'filepath' param).
 *
 * @param value A JSON_Value to be serialized.
 * @param filepath A fully-qualified path to the output file.
 *
 * @return JSON_Status A value indicates whether serialization and file operations are succeeded.
 */
const JSON_Status safe_json_serialize_to_file_pretty(const JSON_Value* value, const char* filepath)
{
    std::string tempFilepath = filepath;
    tempFilepath += std::to_string(std::chrono::system_clock::now().time_since_epoch().count());

    JSON_Status status = json_serialize_to_file_pretty(value, tempFilepath.c_str());
    if (status == JSONSuccess)
    {
        if (rename(tempFilepath.c_str(), filepath) != 0)
        {
            remove(tempFilepath.c_str());
            status = JSONFailure;
        }
    }

    return status;
}

/**
 * @brief Persist specified installedCriteria in a file and mark its state as 'installed'.
 *
 * @param installedCriteriaFilePath A full path to installed criteria data file.
 * @param installedCriteria An installed criteria string.
 *
 * @return bool A boolean indicates whether installedCriteria added successfully.
 */
const bool PersistInstalledCriteria(const char* installedCriteriaFilePath, const std::string& installedCriteria)
{
    Log_Debug("Saving installedCriteria: %s ", installedCriteria.c_str());

    bool success = false;
    JSON_Status status;

    JSON_Value* rootValue = json_parse_file(installedCriteriaFilePath);

    if (rootValue == nullptr)
    {
        rootValue = json_value_init_array();
    }

    if (rootValue != nullptr)
    {
        JSON_Array* rootArray = json_value_get_array(rootValue);
        JSON_Value* icValue = json_value_init_object();
        JSON_Object* icObject = json_value_get_object(icValue);

        if (JSONSuccess == (status = json_object_set_string(icObject, "installedCriteria", installedCriteria.c_str())))
        {
            std::chrono::system_clock::duration timeSinceEpoch = std::chrono::system_clock::now().time_since_epoch();
            const auto seconds = std::chrono::duration_cast<std::chrono::seconds>(timeSinceEpoch).count();

            if (JSONSuccess == (status = json_object_set_string(icObject, "state", "installed")))
            {
                if (JSONSuccess == (status = json_object_set_number(icObject, "timestamp", seconds)))
                {
                    if (JSONSuccess == (status = json_array_append_value(rootArray, icValue)))
                    {
                        status = safe_json_serialize_to_file_pretty(rootValue, installedCriteriaFilePath);
                    }
                }
            }
        }

        success = (status == JSONSuccess);
        json_value_free(rootValue);
    }

    return success;
}

/**
 * @brief Remove specified installedCriteria from installcriteria data file.
 *
 * Note: it will remove duplicate installedCriteria entries.<br/>
 * For example, only the baz array element would remain after a call with "bar" installedCriteria:<br/>
 * \code
 * [
 *   {"installedCriteria": "bar", "state": "installed", "timestamp": "<time 1>"},
 *   {"installedCriteria": "bar", "state": "installed", "timestamp": "<time 2>"},
 *   {"installedCriteria": "baz", "state": "installed", "timestamp": "<time 3>"},
 * ]
 * \endcode
 *
 * @param installedCriteriaFilePath A full path to installed criteria data file.
 * @param installedCriteria An installed criteria string. Case-sensitive match is used.
 *
 * @return bool 'True' if the specified installedCriteria doesn't exist, file doesn't exist, or removed successfully.
 */
const bool RemoveInstalledCriteria(const char* installedCriteriaFilePath, const std::string& installedCriteria)
{
    bool success = true;

    std::ifstream dataFile(installedCriteriaFilePath);
    if (!dataFile.good())
    {
        // File doesn't exist.
        return true;
    }

    JSON_Value* rootValue = json_parse_file(installedCriteriaFilePath);
    if (rootValue != nullptr)
    {
        JSON_Array* icArray = json_value_get_array(rootValue);
        bool mutated = false;

        for (size_t i = json_array_get_count(icArray); i > 0; i--)
        {
            JSON_Object* ic = json_array_get_object(icArray, i - 1);
            if (ic != nullptr)
            {
                const char* id = json_object_get_string(ic, "installedCriteria");
                if (installedCriteria == id)
                {
                    JSON_Status deleted = json_array_remove(icArray, i - 1);
                    if (deleted != JSONSuccess)
                    {
                        // Failed to remove.
                        success = false;
                        break;
                    }

                    // otherwise, keep going to remove duplicates
                    mutated = true;
                }
            }
        }

        if (success && mutated)
        {
            JSON_Status saved = safe_json_serialize_to_file_pretty(rootValue, installedCriteriaFilePath);
            success = (saved == JSONSuccess);
        }

        json_value_free(rootValue);
    }
    else
    {
        success = false;
    }

    return success;
}

void RemoveAllInstalledCriteria()
{
    remove(ADUC_INSTALLEDCRITERIA_FILE_PATH);
}
